# Абстрактная фабрика (Abstract Factory)

#### Известен также под именем
*Kit* (инструментарий).

**Абстрактная фабрика – паттерн, порождающий объекты.**

#### Назначение
Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

#### Применимость
Используйте паттерн абстрактная фабрика, когда:
* система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;
* входящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение этого ограничения;
* система должна конфигурироваться одним из семейств составляющих ее объектов;
* вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

#### Участники
* AbstractFactory – абстрактная фабрика: объявляет интерфейс для операций, создающих абстрактные объекты-продукты;
* ConcreteFactory – конкретная фабрика: реализует операции, создающие конкретные объекты-продукты;
* AbstractProduct – абстрактный продукт: объявляет интерфейс для типа объекта-продукта;
* ConcreteProduct – конкретный продукт: определяет объект-продукт, создаваемый соответствующей конкретной фабрикой; реализует интерфейс AbstractProduct;
* Client – клиент: пользуется исключительно интерфейсами, которые объявлены в классах AbstractFactory и AbstractProduct.

#### Отношения
* Обычно во время выполнения создается единственный экземпляр класса ConcreteFactory. Эта конкретная фабрика создает объекты-продукты,
имеющие вполне определенную реализацию. Для создания других видов объектов клиент должен воспользоваться другой конкретной фабрикой;
* AbstractFactory передоверяет создание объектов-продуктов своему подклассу ConcreteFactory.

#### Результаты
Паттерн абстрактная фабрика обладает следующими плюсами и минусами:
+ *изолирует конкретные классы*. Помогает контролировать классы объектов, создаваемых приложением. Поскольку фабрика инкапсулирует ответственность за создание классов и сам процесс их создания, то она изолирует клиента от деталей реализации классов. Клиенты манипулируют экземплярами через их абстрактные интерфейсы. Имена изготавливаемых классов известны только конкретной фабрике, в коде клиента они не упоминаются;
+ *упрощает замену семейств продуктов*. Класс конкретной фабрики появляется в приложении только один раз: при инстанцировании. Это облегчает замену используемой приложением конкретной фабрики. Приложение может изменить конфигурацию продуктов, просто подставив новую конкретную фабрику. Поскольку абстрактная фабрика создает все семейство продуктов, то и заменяется сразу все семейство.
+ *гарантирует сочетаемость продуктов*. Если продукты некоторого семейства спроектированы для совместного использования, то важно, чтобы приложение в каждый момент времени работало только с продуктами единственного семейства. Класс AbstractFactory позволяет легко соблюсти это ограничение;
- *поддержать новый вид продуктов трудно*. Расширение абстрактной фабрики для изготовления новых видов продуктов – непростая задача. Интерфейс AbstractFactory фиксирует набор продуктов, которые можно создать. Для поддержки новых продуктов необходимо расширить интерфейс фабрики, то есть изменить класс AbstractFactory и все его подклассы. Решение этой проблемы мы обсудим в разделе «Реализация».

#### Реализация
Вот некоторые полезные приемы реализации паттерна абстрактная фабрика:
- *фабрики как объекты, существующие в единственном экземпляре*. Как правило, приложению нужен только один экземпляр класса ConcreteFactory на каждое семейство продуктов. Поэтому для реализации лучше всего применить паттерн одиночка;
- *создание продуктов*. Класс AbstractFactory объявляет только интерфейс для создания продуктов. Фактическое их создание – дело подклассов ConcreteProduct. Чаще всего для этой цели определяется фабричный метод для каждого продукта (см. паттерн фабричный метод). Конкретная фабрика специфицирует свои продукты путем замещения фабричного метода для каждого из них. Хотя такая реализация проста, она требует создавать новый подкласс конкретной фабрики для каждого семейства продуктов, даже если они почти ничем не отличаются.
Если семейств продуктов может быть много, то конкретную фабрику удастся реализовать с помощью паттерна прототип. В этом случае она инициализируется экземпляром-прототипом каждого продукта в семействе и создает новый продукт путем клонирования этого прототипа. Подход на основе прототипов устраняет необходимость создавать новый класс конкретной фабрики для каждого нового семейства продуктов.
- *определение расширяемых фабрик*. Класс AbstractFactory обычно определяет разные операции для каждого вида изготавливаемых продуктов.
Виды продуктов кодируются в сигнатуре операции. Для добавления нового вида продуктов нужно изменить интерфейс класса AbstractFactory
и всех зависящих от него классов.
Более гибкий, но не такой безопасный способ – добавить параметр к операциям, создающим объекты. Данный параметр определяет вид создаваемого объекта. Это может быть идентификатор класса, целое число, строка или что-то еще, однозначно описывающее вид продукта. При таком подходе классу AbstractFactory нужна только одна операция Make с параметром, указывающим тип создаваемого объекта. 
Такой вариант проще использовать в динамически типизированных языках, нежели в статически типизированных. Воспользоваться им в статически типизированном языке можно только, если у всех объектов имеется общий абстрактный базовый класс или если объекты-продукты могут быть безопасно приведены к корректному типу клиентом, который их запросил.
Но даже если приведение типов не нужно, остается принципиальная проблема: все продукты возвращаются клиенту одним и тем же абстрактным
интерфейсом с уже определенным типом возвращаемого значения. Клиент не может ни различить классы продуктов, ни сделать какие-нибудь предположения о них. Если клиенту нужно выполнить операцию, зависящую от подкласса, то она будет недоступна через абстрактный интерфейс. Хотя клиент мог бы выполнить динамическое приведение типа, это небезопасно и необязательно заканчивается успешно. Здесь мы имеем классический пример компромисса между высокой степенью гибкости и расширяемостью интерфейса.

#### Родственные паттерны
Классы AbstractFactory часто реализуются фабричными методами (см. паттерн **фабричный метод**), но могут быть реализованы и с помощью паттерна **прототип**.
Конкретная фабрика часто описывается паттерном **одиночка**.

### Links:
* [refactoring.guru - Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory)
* [Абстрактная фабрика (шаблон проектирования)](https://ru.wikipedia.org/wiki/Абстрактная_фабрика_(шаблон_проектирования))
* [metanit.com - Абстрактная фабрика (Abstract Factory)](https://metanit.com/sharp/patterns/2.2.php)
* Book: Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж. - Приемы объектно-ориентированного проектирования. Паттерны проектирования. Питер. 2015. ISBN 978-5-496-00389-6.
